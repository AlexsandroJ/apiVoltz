#include <ESP32-TWAI-CAN.hpp>
#include <HTTPClient.h>
#include <WiFi.h>
#include <map>

// ------------------------------------------------------------------
// --- CONFIGURA√á√ÉO DE PINOS E VELOCIDADE ---
// ------------------------------------------------------------------
#define CAN_TX_PIN 5 // GPIO 5 (TXD)
#define CAN_RX_PIN 4 // GPIO 4 (RXD)

// CORRIGIDO 1: A biblioteca exige o tipo 'TwaiSpeed' e suas constantes
// internas. Usamos TwaiSpeed e a constante para 250kbps.
const TwaiSpeed CAN_SPEED = TWAI_SPEED_250KBPS;

// Estrutura nativa para frames (a √∫nica que funciona com readFrame)
twai_message_t rxFrame;

// ============== CONFIGURA√á√ïES WIFI ==============
String ssid = "CINGUESTS";
String password = "acessocin";
// =============== Link do server ===================
String url =
    "https://344de5dd1dc5-10-244-13-100-32633.saci.r.killercoda.com/api";
// ============== Estrutura de dados CAN ==============
struct CanMessage {
  String id;
  int dlc;
  String data;
};

// =======================================================
// === ESTRUTURA DE CACHE COM √ÅRVORE DE BUSCA (std::map) ===
// =======================================================
// Chave: ID CAN (uint32_t)
// Valor: Payload (String)
std::map<String, String> canCacheMap;

// Auxiliar para contagem de repeti√ß√µes
int sendCount = 0;
// Tamanho m√°ximo do buffer de mensagens CAN
const int CAN_BUFFER_SIZE = 11;     // Fila suporta at√© 11 mensagens
const int CAN_BUFFER_AUX_SIZE = 10; // Fila suporta at√© 10 mensagens para enviar
const int SEND_THRESHOLD = 10;      // Enviar a cada 10 mensagens
const int CAN_SIMULATION_INTERVAL_MS = 1000; // 1 Hz
const int INTERVAL_1000MS = 1000;            // 1 Hz
const int INTERVAL_100MS = 100;              // 10 Hz
const int INTERVAL_10MS = 10;                // 100 Hz
const int INTERVAL_1MS = 1;                  // 1000 Hz
// ============== Vari√°veis compartilhadas ==============
CanMessage buffer[10];    // Buffer Para envio e leitura
CanMessage bufferAux[10]; // Buffer Auxiliar

QueueHandle_t canQueue;        // Fila para armazenar mensagens CAN
SemaphoreHandle_t canMutex;    // Protege o acesso √† vari√°vel buffer
SemaphoreHandle_t bufferReady; // Sinaliza buffer Pronto para envio

int messageCount = 0; // Contador de mensagens CAN recebidas
uint32_t count = 0;   // Contador de mensagens na fila

// ============== Prot√≥tipo da Task ==============
void telemetriaTask(void *parameter);
void canReaderTask(void *parameter);

void setup() {
  Serial.begin(115200);
  while (!Serial)
    delay(10);

  // Limpeza garantida do cache
  canCacheMap.clear();
  // Cria uma fila (buffer) para armazenar mensagens CAN
  canQueue = xQueueCreate(CAN_BUFFER_SIZE, sizeof(CanMessage));
  if (canQueue == NULL) {
    Serial.println("‚ùå Falha ao criar fila CAN");
    while (1)
      delay(10);
  }
  // Inicializa mutex para proteger o acesso ao dado CAN
  canMutex = xSemaphoreCreateMutex();
  if (canMutex == NULL) {
    Serial.println("‚ùå Falha ao criar mutex para CAN");
    while (1)
      delay(10);
  }
  // Cria sem√°foro de sinaliza√ß√£o
  bufferReady = xSemaphoreCreateBinary();
  if (bufferReady == NULL) {
    Serial.println("‚ùå Falha ao criar sem√°foro de buffer cheio");
    while (1)
      delay(10);
  }
  // Cria a task CAN no N√öCLEO 0
  xTaskCreatePinnedToCore(canReaderTask, "CAN_Reader", 2048, NULL,
                          2, // Prioridade maior que telemetria
                          NULL,
                          0 // N√∫cleo 0
  );

  // Cria a tarefa de telemetria no n√∫cleo 1
  xTaskCreatePinnedToCore(telemetriaTask,   // Fun√ß√£o da tarefa
                          "TelemetriaTask", // Nome amig√°vel
                          10000, // Tamanho da pilha (grande para HTTP)
                          NULL,  // Par√¢metros
                          1,     // Prioridade
                          NULL,  // Handle (n√£o usado)
                          1      // N√∫cleo 1 (deixe o n√∫cleo 0 livre)
  );

  // Serial.println("--- Leitor/Sniffer CAN ESP32 (TJA1050) - Vers√£o Final
  // ---");

  // 1. Configura os pinos antes de iniciar o driver CAN
  ESP32Can.setPins(CAN_TX_PIN, CAN_RX_PIN);

  // 2. Inicializa o controlador CAN. Agora passa a constante TwaiSpeed.
  if (ESP32Can.begin(CAN_SPEED)) {
    Serial.println("Controlador CAN (TWAI) iniciado com sucesso!");
    // Serial.println("Monitorando em 250 kbps nos pinos TX:5 e RX:4...");
  } else {
    Serial.println(
        "ERRO: Falha ao iniciar o controlador CAN! Verifique as conex√µes.");
    while (1)
      delay(100);
  }
}

// ------------------------------------------------------------------
// --- LOOP PRINCIPAL (LEITURA DE DADOS) ---
// ------------------------------------------------------------------
void loop() { delay(1); }

void canReaderTask(void *parameter) {
  (void)parameter;
  int messageCounter = 0;
  String data_string = "";

  for (;;) {

    if (ESP32Can.readFrame(&rxFrame)) {

      // Serial.println("---------------------------------------------");
      // Serial.println("PACOTE RECEBIDO:");

      // 1. ID da Mensagem
      // Serial.print("  ID: 0x");

      // CORRIGIDO 2: Acessa o bit EXT_FLAG (0x01) na union flags para verificar
      // ID Estendido Esta √© a forma correta para o driver TWAI.
      if (rxFrame.flags & TWAI_MSG_FLAG_EXTD) {
        // Serial.print(rxFrame.identifier, HEX);
        // Serial.print(" (Estendido)");
      } else {
        // Serial.print(rxFrame.identifier, HEX);
        // Serial.print(" (Padr√£o)");
      }

      // 2. Comprimento dos Dados (DLC)
      // Serial.print(", DLC: ");
      // Serial.println(rxFrame.data_length_code); // Este membro j√° estava
      // correto

      // 3. Dados (Payload)
      // Serial.print("  Dados (HEX): ");

      data_string = "";
      // Usa 'data_length_code' para limitar o loop de dados.
      for (int i = 0; i < rxFrame.data_length_code; i++) {
        byte dataByte = rxFrame.data[i];

        // === CR√çTICO: FORMATA√á√ÉO EM HEX DE 2 D√çGITOS ===
        if (dataByte < 0x10) {
          data_string += "0";
        }
        data_string +=
            String(dataByte, HEX); // Garante formato "0A" ao inv√©s de "A"

        // Se N√ÉO for o √∫ltimo elemento (i < 7), adiciona um espa√ßo.
        if (i < (rxFrame.data_length_code - 1)) {
          data_string += " ";
        }

        /*
        // Formata a sa√≠da para 2 d√≠gitos em HEX
        if (dataByte < 0x10)
          Serial.print("0");
        Serial.print(dataByte, HEX);
        Serial.print(" ");
      }
      Serial.println();

      */
      }
      CanMessage newMsg = {.id = String(rxFrame.identifier),
                           .dlc = rxFrame.data_length_code,
                           .data = data_string};

      // -----------------------------------------------------------------
      // --- CHAMADA PARA A FUN√á√ÉO DE VERIFICA√á√ÉO ---
      // -----------------------------------------------------------------
      if (!isDataChangedAndCache(newMsg.id, newMsg.data)) {
        // Se a fun√ß√£o retornar FALSE, o dado n√£o mudou. Descarta e continua.
        // Serial.printf("üò¥ CAN ID 0x%X sem altera√ß√£o.
        // Descartando.\n",rxFrame.identifier);
        vTaskDelay(1 / portTICK_PERIOD_MS);
        continue;
      }

      // Tenta adicionar na fila (n√£o bloqueante)
      if (xQueueSendToBack(canQueue, &newMsg,
                           INTERVAL_100MS / portTICK_PERIOD_MS) != pdTRUE) {
        Serial.println("‚ö†Ô∏è Buffer CAN cheio! Mensagem perdida.");
      } else {
        count = uxQueueMessagesWaiting(canQueue);
        // Se atingiu 1000, sinaliza
        if (count == SEND_THRESHOLD) {
          Serial.printf(
              "üîî %d mensagens armazenadas! Avisando para enviar...\n", count);
          int sentCount = 0;

          // Protege a escrita com mutex
          if (xSemaphoreTake(canMutex, INTERVAL_1MS / portTICK_PERIOD_MS)) {
            // L√™ at√© 10 mensagens da fila ‚Üí elas s√£o REMOVIDAS
            // automaticamente
            while (sentCount < SEND_THRESHOLD &&
                   xQueueReceive(canQueue, &newMsg, 0) == pdTRUE) {
              buffer[sentCount++] = newMsg;
            }
            // Sinaliza que h√° 10 mensagens para enviar
            xSemaphoreGive(bufferReady);
            xSemaphoreGive(canMutex);
          }
        }
        Serial.printf("%d üì® CAN armazenado: ID=%s DLC=%d Data=%s\n", count,
                      newMsg.id.c_str(), newMsg.dlc, newMsg.data.c_str());
      }
    }
  }
}

// ============== TASK 2: Envio de Telemetria ==============
void telemetriaTask(void *parameter) {
  (void)parameter; // Ignora par√¢metro n√£o usado
  Serial.println("Conectando ao Wi-Fi...");
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println();
  Serial.println("‚úÖ Conectado ao Wi-Fi!");
  Serial.print("IP: ");
  Serial.println(WiFi.localIP());

  unsigned long lastSend = 0;
  for (;;) { // Loop infinito da tarefa
    unsigned long currentMillis = millis();
    if (xSemaphoreTake(bufferReady, INTERVAL_10MS / portTICK_PERIOD_MS) ==
        pdTRUE) {
      Serial.println("üöÄ Sinal recebido! Enviando 10 mensagens...");
      // Protege a escrita com mutex
      if (xSemaphoreTake(canMutex, INTERVAL_10MS / portTICK_PERIOD_MS)) {
        for (int i = 0; i < SEND_THRESHOLD; i++) {
          bufferAux[i] = buffer[i];
        }
        xSemaphoreGive(canMutex);
      }
      // Verifica conex√£o Wi-Fi
      if (WiFi.status() != WL_CONNECTED) {
        Serial.println("‚ùå Wi-Fi desconectado. Tentando reconectar...");
        WiFi.reconnect();
        delay(2000);
        if (WiFi.status() != WL_CONNECTED) {
          continue;
        }
      }
      HTTPClient http;
      http.setTimeout(10000); // Timeout de 10 segundos
      // Tenta iniciar conex√£o
      if (!http.begin(url)) {
        Serial.println("‚ùå Falha ao iniciar HTTP. URL inv√°lida?");
        continue;
      }

      http.addHeader("Content-Type", "application/json");

      String jsonData = "{";
      jsonData += "\"speed\": 48,";
      jsonData += "\"battery\": {\"soc\": 76, \"soh\": 94, \"voltage\": 71.8, "
                  "\"current\": -3.4, \"temperature\": 31.2},";
      jsonData += "\"motor\": {\"rpm\": 3600, \"power\": 9.8, \"regenLevel\": "
                  "40, \"motorTemp\": 68, \"inverterTemp\": 61},";
      jsonData += "\"location\": {\"type\": \"Point\", \"coordinates\": "
                  "[-45.6333, -23.5500]},";
      jsonData += "\"driveMode\": \"sport\",";
      jsonData += "\"range\": 74,";
      jsonData += "\"vehicleStatus\": \"ligado\",";
      jsonData += "\"odometer\": 1247.3,";
      jsonData += "\"alerts\": [{";
      jsonData += "  \"code\": \"MOTOR_OVERHEAT_WARNING\",";
      jsonData += "  \"message\": \"Temperatura do motor acima de 65¬∞C\",";
      jsonData += "  \"severity\": \"warning\"";
      jsonData += "}],";
      jsonData += "\"canMessages\": [";

      for (int i = 0; i < SEND_THRESHOLD; i++) {
        jsonData += "{";
        jsonData += "\"canId\": \"" + bufferAux[i].id + "\",";
        jsonData += "\"data\": \"" + bufferAux[i].data + "\",";
        jsonData +=
            "\"dlc\": " + String(bufferAux[i].dlc); // ‚úÖ Sem v√≠rgula aqui
        jsonData += "}";                            // Fecha o objeto

        if (i < SEND_THRESHOLD - 1) {
          jsonData += ","; // ‚úÖ V√≠rgula entre objetos do array
        }
      }
      jsonData += "]"; // Fecha o array canMessages
      jsonData += "}"; // Fecha o JSON principal
      sendCount++;
      Serial.printf("%d  üì§ Enviando telemetria...\n", sendCount);
      int httpResponseCode = http.POST(jsonData);

      if (httpResponseCode > 0) {
        switch (httpResponseCode) {
        case 200:
        case 201:
        case 204:
          Serial.printf("‚úÖ Sucesso! C√≥digo HTTP: %d\n", httpResponseCode);
          break;

        case 400:
          Serial.println(
              "‚ùå Requisi√ß√£o inv√°lida. JSON mal formado ou campos faltando.");
          break;

        case 401:
        case 403:
          Serial.println(
              "üîê Falha de autentica√ß√£o. Verifique token ou API key.");
          break;

        case 404:
          Serial.println("üîç Endpoint n√£o encontrado. Verifique a URL.");
          break;

        case 413:
          Serial.println("üì¶ Payload muito grande. Envie em lotes menores.");
          break;

        case 429:
          Serial.println("‚è≥ Muitas requisi√ß√µes. Aumente o intervalo.");
          break;

        default:
          if (httpResponseCode >= 400 && httpResponseCode < 500) {
            Serial.printf("‚ùå Erro do cliente: %d\n", httpResponseCode);
          } else if (httpResponseCode >= 500) {
            Serial.printf(
                "üîß Erro do servidor: %d. Tente novamente mais tarde.\n",
                httpResponseCode);
          } else {
            Serial.printf("‚ö†Ô∏è  Resposta inesperada: %d\n", httpResponseCode);
          }
          break;
        }
      } else {
        Serial.printf("‚ùå Falha na requisi√ß√£o. C√≥digo: %d\n", httpResponseCode);
      }
      http.end(); // Sempre encerre a conex√£o
    }
    // ‚è±Ô∏è Libera o n√∫cleo por 10ms (evita travar o FreeRTOS)
    vTaskDelay(INTERVAL_10MS / portTICK_PERIOD_MS);
  }
}

/**
 * @brief Verifica se os dados s√£o diferentes da √∫ltima vez usando std::map.
 * Se forem, atualiza o cache (insert ou update).
 * * @param canIdString O identificador da mensagem CAN no formato String.
 * @param newData A string de dados rec√©m-formatada em HEX de largura fixa.
 * @return true se os dados mudaram (ou se for um novo ID), false se os dados
 * s√£o iguais.
 */
bool isDataChangedAndCache(const String &canIdString, const String &newData) { // <-- ID agora √© String
    
    // 1. Busca: Tenta encontrar o ID (String) no mapa
    auto it = canCacheMap.find(canIdString); // Busca pela String

    // ===================================================
    // === ID ENCONTRADO (Mensagem j√° existe no cache) ===
    // ===================================================
    if (it != canCacheMap.end()) {
        
        // 2. Compara√ß√£o
        if (it->second == newData) {
            return false; // DADOS S√ÉO IGUAIS. Descartar.
        }
        
        // 3. Atualiza√ß√£o (Dados mudaram)
        it->second = newData; // Atualiza a string do payload no cache
        Serial.printf("‚ú® ID %s atualizado.\n", canIdString.c_str());
        return true; // DADOS MUDARAM. Enviar.

    } 
    
    // ===================================================
    // === ID N√ÉO ENCONTRADO (Mensagem √© nova) ===
    // ===================================================
    else {
        
        // 4. Inser√ß√£o: Adiciona o novo ID e o dado
        canCacheMap[canIdString] = newData;
        
        // O log aparecer√° AQUI. Adicionado +1 pois o size ainda n√£o foi atualizado.
        Serial.printf("‚ú® NOVO ID %s adicionado √† √°rvore de busca (%d entradas).\n", 
            canIdString.c_str(), canCacheMap.size());
            
        return true; // √â novo. Enviar.
    }
}
